#Looping on the Command Line

#laaply: Loop over a list and evaluate a function on each element
#sapply: Same as lapply but try to simplify the result
#apply: Apply a function over the margins of an array
#tapply: Apply a function over subsets of a vector
#mapply: Multivariate version of lapply
#An auxiliary split is also useful, particularly in conjunction with lapply.

#lapply takes three arguments: (1) a list x; (2) a function (or the name of a function) FUN; #other arguments via its ... argument. If x is not a list, it will be coerced to a list using as.list.
#lapply always return a list, regardlees of the class of the input.

#sapply will try to simplify the result of lapply if possible
#If the result is a list where every element is a vector of the same length(>1), a matrix is #returned.
#If can't figure things out, a list is returned.

#apply is used to a evaluate a function(often an anonymous one) over the margins of an array.
#It is most often used to apply a function to the rows or columns of a matrix
#It can be used with general arrays, e.g. taking the average of an array of matrices
#It is not really faster than writing a loop, but it works in one line!
#str(apply) => function(X, MARGIN, FUN, ...)
#X is an array
#Margin is an integer vector indicating wich margins should be "retained".
#FUN is a function to be applied
#... is for other arguments to be passed to FUN

#col/row sums and means
#For sums and means of matrix dimensions, we have some shortcuts.
#rowSums = apply(x, 1, sum)
#rowMeans = apply(x, 1, mean)
#colSums = apply(x, 2, sum)
#colMeans = apply(x, 2, mean)
#The shortcut function are much faster, but you won't notice unless you're using a large matrix.

#mapply is a multivariate apply of sorts wich applies a function in parallel over a set of arguments.
#str(mapply) => function (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)
#Fun is a function to apply
#...contains arguments to apply over
#MoreArgs iis a list of other arguments to FUN
#SIMPLIFY indicates whether the result should be simplified

#Vectorizing a Function
noise <- function(n, mean, sd){
rnorm(n, mean, sd)
}
noise(5, 1, 2)

mapply(noise, 1:5, 1:5, 2)

#Instant Vectorization
#Wich is the same as
list(noise, 1, 1, 2), noise(2, 2, 2), 
      noise(3, 3, 2), noise(4, 4, 2),
      noise(5, 5, 2))

#tapply is used to apply a function over subsets of a vector. I don't know why it's called tapply.
str(tapply) => function (X, INDEX, FUN = NULL, ..., simplify = TRUE)
#X is a vector
#INDEX is a factor or a list of factors(or else they are coerced to factors)
#FUN is a function to be applied
#...contains other arguments to be passed FUN
#simplify, shoud we simplify the result?

#split takes a vector or other objects and splits it into groups determined by a factor or list of factors.
#str(split) => function (x, f, drop = FALSE, ...)  
#A common idiom is split followed by an lapply.

#Splitting a Data Frame
library(datasets)
head(airquality)
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm = TRUE))

#Splitting on More than One Level
x <- rnorm(10)
f1 <- gl(2, 5)
f2 <- gl(5, 2)
f1
f2
interaction(f1, f2)

str(split(x, list(f1, f2)))

#Split
#Empty levels can be dropped.
str(split(x, list(f1, f2), drop = TRUE))

