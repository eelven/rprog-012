#Looping on the Command Line

#laaply: Loop over a list and evaluate a function on each element
#sapply: Same as lapply but try to simplify the result
#apply: Apply a function over the margins of an array
#tapply: Apply a function over subsets of a vector
#mapply: Multivariate version of lapply
#An auxiliary split is also useful, particularly in conjunction with lapply.

#lapply takes three arguments: (1) a list x; (2) a function (or the name of a function) FUN; #other arguments via its ... argument. If x is not a list, it will be coerced to a list using as.list.
#lapply always return a list, regardlees of the class of the input.

#sapply will try to simplify the result of lapply if possible
#If the result is a list where every element is a vector of the same length(>1), a matrix is #returned.
#If can't figure things out, a list is returned.

#apply is used to a evaluate a function(often an anonymous one) over the margins of an array.
#It is most often used to apply a function to the rows or columns of a matrix
#It can be used with general arrays, e.g. taking the average of an array of matrices
#It is not really faster than writing a loop, but it works in one line!
#str(apply) => function(X, MARGIN, FUN, ...)
#X is an array
#Margin is an integer vector indicating wich margins should be "retained".
#FUN is a function to be applied
#... is for other arguments to be passed to FUN

#col/row sums and means
#For sums and means of matrix dimensions, we have some shortcuts.
#rowSums = apply(x, 1, sum)
#rowMeans = apply(x, 1, mean)
#colSums = apply(x, 2, sum)
#colMeans = apply(x, 2, mean)
#The shortcut function are much faster, but you won't notice unless you're using a large matrix.

#mapply is a multivariate apply of sorts wich applies a function in parallel over a set of arguments.
#str(mapply) => function (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)
#Fun is a function to apply
#...contains arguments to apply over
#MoreArgs iis a list of other arguments to FUN
#SIMPLIFY indicates whether the result should be simplified

#Vectorizing a Function
noise <- function(n, mean, sd){
rnorm(n, mean, sd)
}
noise(5, 1, 2)

mapply(noise, 1:5, 1:5, 2)

#Instant Vectorization
#Wich is the same as
list(noise, 1, 1, 2), noise(2, 2, 2), 
      noise(3, 3, 2), noise(4, 4, 2),
      noise(5, 5, 2))

#tapply is used to apply a function over subsets of a vector. I don't know why it's called tapply.
str(tapply) => function (X, INDEX, FUN = NULL, ..., simplify = TRUE)
#X is a vector
#INDEX is a factor or a list of factors(or else they are coerced to factors)
#FUN is a function to be applied
#...contains other arguments to be passed FUN
#simplify, shoud we simplify the result?

#split takes a vector or other objects and splits it into groups determined by a factor or list of factors.
#str(split) => function (x, f, drop = FALSE, ...)  
#A common idiom is split followed by an lapply.

#Splitting a Data Frame
library(datasets)
head(airquality)
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm = TRUE))

#Splitting on More than One Level
x <- rnorm(10)
f1 <- gl(2, 5)
f2 <- gl(5, 2)
f1
f2
interaction(f1, f2)

str(split(x, list(f1, f2)))

#Split
#Empty levels can be dropped.
str(split(x, list(f1, f2), drop = TRUE))

#Debugging
Something's wrong!
Indications that something;s not right
message: A generic notification/diagnostic message produced by the message function; execution of the function continues
warning: An indication that something is wrong but not necessarily fatal; execution of the function continues; generated by the warning function
error: An indication that a faltal problem has occurred; execution stops; produced by the stop function
condition: A generic concept for indicating that something unexpected can occur; programmers can create theis own conditions
log(-1)
[1] NaN
Warning message:
In log(-1) : NaNs produced

printmessage <- function(x){
     if(x > 0)
         print("x is grater than zero")
     else
         print("x is less than or equal to zero")
     invisible(x)
 }
> printmessage(1)
[1] "x is grater than zero"
>
> printmessage(NA)
Error in if (x > 0) print("x is grater than zero") else print("x is less than or equal to zero") : 
  missing value where TRUE/FALSE needed
 
  
  printmessage2 <- function(x){
     if(is.na(x))
         print("x is a missing value!")
     else if(x > 0)
         print("x is greater than zero")
     else
         print("x is less than or equal to zero")
     invisible(x)
 }
> 
> printmessage2(NA)
[1] "x is a missing value!"
> printmessage2(4)
[1] "x is greater than zero"
> printmessage2(-1)
[1] "x is less than or equal to zero"

x <- log(-1)
Warning message:
In log(-1) : NaNs produced
> printmessage2(x)
[1] "x is a missing value!"

Something's Wrong!
How do you know that something is wrong with your function?
What was your input? How did you call the function ?
What were you expecting? Output, messages, other results?
What did you get?
How does what you get differ from what you were expecting?
Were your expectations correct in the first place?
Can you reproduce the problem(exactly)?

Debugging Tools in R
The primary tools for debugging functions in R are
traceback: prints out the function call stack after an error occurs; does nothing if there's no error
debug: flags a function for "debug" mode wich allows you to step through execution of a function one line at a time
browser: suspends the exection of a function wherever it is called and puts the function in debug mode
trace: allows you to insert debugging code into a function a specific places
recover: allows you to modify the error behavior so that you can browse the function stack
These are interactive tools specifically designed to allow you to pick through a function. There's also the more blunt technique of inserting print/cat statements in the function

traceback
>mean(x)
Error in mean(x): object 'x' not found
>traceback()
1: mean()
>
traceback
> lm(y ~ x)
Error in eval(expr, envir, enclos) : object 'y' not found
> traceback()
7: eval(expr, envir, enclos)
6: eval(predvars, data, env)
5: model.frame.default(formula = y ~ x, drop.unused.levels = TRUE)
4: stats::model.frame(formula = y ~ x, drop.unused.levels = TRUE)
3: eval(expr, envir, enclos)
2: eval(mf, parent.frame())
1: lm(y ~ x)
> 

debug
debug(lm)
> lm(y ~ x)
debugging in: lm(y ~ x)
debug: {
    ret.x <- x
    ret.y <- y
    cl <- match.call()
    ...
    if (!qr) 
        z$qr <- NULL
    z
}
Browse[2]> 

Browse[2]> n
debug: ret.x <- x
Browse[2]> n
debug: ret.y <- y
Browse[2]> n
debug: cl <- match.call()
Browse[2]> n
debug: mf <- match.call(expand.dots = FALSE)
Browse[2]> n
debug: m <- match(c("formula", "data", "subset", "weights", "na.action", 
    "offset"), names(mf), 0L)
    
recover
> options(error = recover)
> read.csv("nosuchfile")
Error in file(file, "rt") : cannot open the connection
In addition: Warning message:
In file(file, "rt") :
  cannot open file 'nosuchfile': No such file or directory

Enter a frame number, or 0 to exit   

1: read.csv("nosuchfile")
2: read.table(file = file, header = header, sep = sep, quote = quote, dec = dec, fill = fill, comme
3: file(file, "rt")

Selection: 

Debugging
Summary
There are main indications of a problem/condition: message, warning, error
- only an error is fatal
When analyzing a function with a problem, make sure you can reproduce the problem, clearly state your expectations and how the output differs from your expectation
Interactive debugging tools traceback, debug, browser, trace and recover can be used to find problematic code in functions
Debugging tools are not a substitute for thinking!

